type Stringifier = (value: unknown) => string;

/**
 * Configuration options for the unique value generation process.
 *
 * @template Result The type of the result generated by the function.
 * @template TStringifier The type of the optional stringifier function. When provided, the store and exclude list operate on stringified values.
 *
 * @property {Set<Result> | Set<string>} [store] - Optional store to keep track of unique values. If a stringifier is provided, the store is a `Set<string>`. Otherwise, it's a `Set<Result>`.
 * @property {number} [maxRetries=50] - The maximum number of retries allowed to generate a unique value before throwing an error. Defaults to 50.
 * @property {number} [maxTime=50] - The maximum time allowed (in milliseconds) for generating a unique value before throwing an error. Defaults to 50ms.
 * @property {unknown[]} [exclude] - A list of values to be excluded from the result set. When a stringifier is provided, the list will be stringified.
 * @property {TStringifier} [stringifier] - A function to stringify a result value before storing it in the set or checking for uniqueness. If provided, it ensures that the store and exclude list work with stringified values.
 */
type IOptions<
  Result,
  TStringifier extends Stringifier | undefined,
> = TStringifier extends Stringifier
  ? {
      store?: Set<string>;
      maxRetries?: number;
      maxTime?: number;
      exclude?: unknown[];
      stringifier: TStringifier;
    }
  : {
      store?: Set<Result>;
      maxRetries?: number;
      maxTime?: number;
      exclude?: unknown[];
      stringifier?: undefined;
    };

/**
 * Creates a function that generates unique values based on the passed function `fn`.
 * The function ensures uniqueness by storing generated values and retrying if duplicates are found.
 *
 * @template Fn The type of the function passed to generate values.
 * @template TStringifier The type of the optional stringifier function. When provided, it stringifies the results before storing them in the set.
 *
 * @param {Fn} fn - The function that generates values. This function can accept arguments and return any type of value.
 * @param {IOptions<ReturnType<Fn>, TStringifier>} [options={}] - Optional configuration for controlling the uniqueness generation process, such as the store, retries, and maximum time.
 * @returns {(args: Parameters<Fn>) => ReturnType<Fn>} A new function that generates unique values based on `fn`, ensuring that values are unique across invocations according to the provided configuration.
 *
 * @throws {Error} Throws an error if the max retries or max time is exceeded while trying to generate a unique value.
 *
 * @example
 * ```ts
 * import { uniqueFactory } from '@dpaskhin/unique';
 * import { faker } from '@faker-js/faker';
 *
 * // Create a unique generator for first names
 * const uniqueNameGen = uniqueFactory(faker.person.firstName);
 *
 * const name1 = uniqueNameGen(); // Generate a unique name
 * const name2 = uniqueNameGen(); // Generate another unique name
 *
 * console.log(name1, name2); // Outputs two different names
 * ```
 *
 * @example
 * ```ts
 * import { uniqueFactory } from '@dpaskhin/unique';
 * import { faker } from '@faker-js/faker';
 *
 * // Create a unique generator for objects using a stringifier
 * const personGen = () => ({
 *   name: faker.person.firstName(),
 *   age: faker.date.birthdate().toLocaleDateString(),
 * });
 * const stringifier = (value: unknown) => JSON.stringify(value);
 *
 * const person1 = unique(personGen, [], { stringifier });
 * const person2 = unique(personGen, [], { stringifier });
 *
 * console.log(person1, person2); // Outputs two unique persons
 * ```
 */
export function uniqueFactory<
  Fn extends (...args: any[]) => any,
  TStringifier extends Stringifier | undefined,
>(
  fn: Fn,
  options: IOptions<ReturnType<Fn>, TStringifier> = {} as IOptions<
    ReturnType<Fn>,
    TStringifier
  >
): (...args: Parameters<Fn>) => ReturnType<Fn> {
  let {
    store = new Set(),
    maxRetries = 50,
    maxTime = 50,
    exclude = [],
    stringifier,
  } = options;

  if (stringifier) {
    exclude = exclude.map(value => stringifier(value));
  }

  return function (...args) {
    let result: ReturnType<Fn>;
    let currentIterations = 0;
    let startTime = Date.now();

    while (true) {
      let now = Date.now();
      let duration = now - startTime;

      if (duration >= maxTime) {
        throw new Error(
          createErrorMessage(
            'Exceeded maxTime: ' + maxTime,
            store.size,
            duration,
            currentIterations
          )
        );
      }

      if (currentIterations >= maxRetries) {
        throw new Error(
          createErrorMessage(
            'Exceeded maxTries: ' + maxRetries,
            store.size,
            duration,
            currentIterations
          )
        );
      }

      result = fn.apply(null, args);

      let tmpResult = stringifier ? stringifier(result) : result;

      currentIterations++;

      if (!store.has(tmpResult) && !exclude.includes(tmpResult)) {
        store.add(tmpResult);
        break;
      }
    }

    return result;
  };
}

/**
 * A global store to track unique values across multiple invocations of the `unique` function.
 * This can be shared across different parts of the code to ensure unique values globally.
 *
 * **Example:**
 *
 * @example
 * ```ts
 * const randomValueGen = () => Math.random();
 *
 * const uniqueRandomValue1 = unique(randomValueGen); // Uses GLOBAL_STORE
 * const uniqueRandomValue2 = unique(randomValueGen); // Uses GLOBAL_STORE to ensure global uniqueness
 *
 * console.log(uniqueRandomValue1, uniqueRandomValue2); // Outputs two unique values
 *
 * // Clear the global store when needed
 * GLOBAL_STORE.clear();
 * ```
 */
export const GLOBAL_STORE = new Set();

/**
 * Generates a unique value using the provided function `fn` that takes no arguments.
 * It ensures uniqueness by checking against previous results stored either in the provided `store` or the global store.
 *
 * **Note:** The global store is shared across multiple invocations, and values will persist globally.
 * If you need isolation between different parts of your application, you should provide a custom `store` in the options.
 *
 * **Best Practice:** Avoid using the global store in environments where global uniqueness is not needed,
 * as it may lead to unexpected results due to shared state.
 *
 * @template Fn The type of the function that generates values without arguments.
 * @template TStringifier The type of the optional stringifier function. If provided, it will be used to stringify the results before storing them.
 *
 * @param {Fn} fn - The function to generate values. This function does not accept any arguments.
 * @param {never[]} [args] - No arguments are passed to functions that do not accept arguments. This is automatically inferred.
 * @param {IOptions<ReturnType<Fn>, TStringifier>} [options] - Optional configuration for controlling the uniqueness generation process, such as store, retries, max time, and a stringifier.
 * @returns {ReturnType<Fn>} The unique value generated by the function `fn`.
 *
 * @throws {Error} Throws an error if the max retries or max time is exceeded while trying to generate a unique value.
 *
 * @example
 * ```ts
 * import { unique } from '@dpaskhin/unique';
 * import { faker } from '@faker-js/faker';
 *
 * // Example with a function that takes no arguments
 * const uniqueBio = unique(faker.person.bio);
 * console.log(uniqueBio); // Outputs a unique user's bio
 * ```
 *
 * @example
 * ```ts
 * import { unique } from '@dpaskhin/unique';
 *
 * // Example with a function that takes no arguments and a custom store
 * const uniqueRandomNumber = unique(Math.random, [], {
 *   store: new Set<number>(), // Using a custom store
 *   maxRetries: 5,
 * });
 * console.log(uniqueRandomNumber); // Outputs a unique random number
 * ```
 */
export function unique<
  Fn extends () => any,
  TStringifier extends Stringifier | undefined,
>(
  fn: Fn,
  args?: never[],
  options?: IOptions<ReturnType<Fn>, TStringifier>
): ReturnType<Fn>;

/**
 * Generates a unique value using the provided function `fn` that accepts arguments.
 * It ensures uniqueness by checking against previous results stored either in the provided `store` or the global store.
 *
 * **Note:** The global store is shared across multiple invocations, and values will persist globally.
 * If you need isolation between different parts of your application, you should provide a custom `store` in the options.
 *
 * **Best Practice:** Avoid using the global store in environments where global uniqueness is not needed,
 * as it may lead to unexpected results due to shared state.
 *
 * @template Fn The type of the function that generates values and accepts arguments.
 * @template TStringifier The type of the optional stringifier function. If provided, it will be used to stringify the results before storing them.
 *
 * @param {Fn} fn - The function to generate values. This function must accept arguments.
 * @param {Parameters<Fn>} args - The arguments to be passed to the function `fn`.
 * @param {IOptions<ReturnType<Fn>, TStringifier>} [options] - Optional configuration for controlling the uniqueness generation process, such as store, retries, max time, and a stringifier.
 * @returns {ReturnType<Fn>} The unique value generated by the function `fn`.
 *
 * @throws {Error} Throws an error if the max retries or max time is exceeded while trying to generate a unique value.
 *
 * @example
 * ```ts
 * import { unique } from '@dpaskhin/unique';
 * import { faker } from '@faker-js/faker';
 *
 * // Example with a function that takes arguments
 * const uniqueEmailGen = (firstName: string, lastName: string) => {
 *   return faker.internet.email({ firstName, lastName });
 * };
 * const uniqueEmail = unique(uniqueEmailGen, ['John', 'Doe'], { maxRetries: 5 });
 * console.log(uniqueEmail); // Outputs a unique random email
 * ```
 *
 * @example
 * ```ts
 * import { unique } from '@dpaskhin/unique';
 * import { faker } from '@faker-js/faker';
 *
 * // Example with a function that takes arguments and uses a stringifier
 * const userGen = (name: string, age: number) => ({ name, age });
 * const uniqueUser = unique(
 *   userGen,
 *   [faker.person.firstName(), faker.number.int({ min: 18, max: 100 })],
 *   {
 *     stringifier: value => JSON.stringify(value), // Stringify the object for uniqueness checks
 *     maxRetries: 10,
 *   }
 * );
 * console.log(uniqueUser); // Outputs a unique user
 * ```
 */
export function unique<
  Fn extends (...args: any[]) => any,
  TStringifier extends Stringifier | undefined,
>(
  fn: Fn,
  args: Parameters<Fn>,
  options?: IOptions<ReturnType<Fn>, TStringifier>
): ReturnType<Fn>;

/**
 * Generates a unique value using the provided function `fn`, ensuring uniqueness based on previous results stored in a custom store or the global store.
 * The function `fn` can either take arguments or not, and the default value for `args` will be an empty array if not provided.
 * If a `stringifier` is provided, values are stringified before being stored or checked for uniqueness.
 *
 * **Note:** The global store is shared across multiple invocations, and values will persist globally.
 * If you need isolation between different parts of your application, you should provide a custom `store` in the options.
 *
 * **Best Practice:** Avoid using the global store in environments where global uniqueness is not needed,
 * as it may lead to unexpected results due to shared state.
 *
 * @template Fn The type of the function that generates values.
 * @template TStringifier The type of the optional stringifier function. If provided, results are stringified before being stored in the set or checked for uniqueness.
 *
 * @param {Fn} fn - The function to generate values. This function may or may not accept arguments.
 * @param {Parameters<Fn>} [args=[]] - The arguments to be passed to the function `fn`. Defaults to an empty array if no arguments are needed.
 * @param {IOptions<ReturnType<Fn>, TStringifier>} [options={}] - Optional configuration for controlling the uniqueness generation process, including the store, maxRetries, maxTime, and a stringifier.
 * @returns {ReturnType<Fn>} The unique value generated by the function `fn`.
 *
 * @throws {Error} Throws an error if the max retries or max time is exceeded while trying to generate a unique value.
 *
 * @example
 * ```ts
 * import { unique } from '@dpaskhin/unique';
 * import { faker } from '@faker-js/faker';
 *
 * // Example with a function that takes no arguments
 * const uniqueFirstName = unique(faker.person.firstName);
 * console.log(uniqueFirstName); // Outputs a unique first name
 * ```
 *
 * @example
 * ```ts
 * import { unique } from '@dpaskhin/unique';
 * import { faker } from '@faker-js/faker';
 *
 * // Example with a function that takes arguments
 * const uniqueEmailGen = (firstName: string, lastName: string) => {
 *   return faker.internet.email({ firstName, lastName });
 * };
 * const uniqueEmail = unique(uniqueEmailGen, ['John', 'Doe'], { maxRetries: 5 });
 * console.log(uniqueEmail); // Outputs a unique random email
 * ```
 *
 * @example
 * ```ts
 * import { unique } from '@dpaskhin/unique';
 *
 * // Example with a stringifier to handle objects
 * const userGen = (name: string, age: number) => ({ name, age });
 * const uniqueUser = unique(
 *   userGen,
 *   [faker.person.firstName(), faker.number.int({ min: 18, max: 100 })],
 *   {
 *     stringifier: value => JSON.stringify(value), // Stringify objects for uniqueness checks
 *     maxRetries: 10,
 *   }
 * );
 * console.log(uniqueUser); // Outputs a unique user
 * ```
 */
export function unique<
  Fn extends (...args: any[]) => any,
  TStringifier extends Stringifier | undefined,
>(
  fn: Fn,
  args: Parameters<Fn> = [] as unknown as Parameters<Fn>,
  options: IOptions<ReturnType<Fn>, TStringifier> = {} as IOptions<
    ReturnType<Fn>,
    TStringifier
  >
): ReturnType<Fn> {
  return uniqueFactory(
    fn,
    Object.assign(options, { store: options.store || GLOBAL_STORE })
  ).apply(null, args);
}

function createErrorMessage(
  code: string,
  storeSize: number,
  duration: number,
  currentIterations: number
): string {
  return `
  ${code} for uniqueness check.
    
Found ${storeSize} unique entries before throwing error.
retried: ${currentIterations}
total time: ${duration}ms

May not be able to generate any more unique values with current settings.
Try adjusting maxTime or maxRetries parameters.`;
}
